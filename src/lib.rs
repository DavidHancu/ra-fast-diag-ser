use lsp_types::{Diagnostic, DiagnosticRelatedInformation, NumberOrString};

pub fn serde_serialize_diagnostic(diagnostic: &Diagnostic) -> String {
    serde_json::to_string(&diagnostic).unwrap()
}

pub fn sonic_serialize_diagnostic(diagnostic: &Diagnostic) -> String {
    sonic_rs::to_string(&diagnostic).unwrap()
}

/// This is normaly generated by a macro, but I've copied the generated implementation and renamed some variables
/// so it can be improved more easily.
pub fn fast_serialize_error_diagnostic(diagnostic: &Diagnostic) -> Vec<u8> {
    let mut numbuf = itoa::Buffer::new();
    let range_start_line = numbuf.format(diagnostic.range.start.line);
    let mut numbuf = itoa::Buffer::new();
    let range_start_character = numbuf.format(diagnostic.range.start.character);
    let mut numbuf = itoa::Buffer::new();
    let range_end_line = numbuf.format(diagnostic.range.end.line);
    let mut numbuf = itoa::Buffer::new();
    let range_end_character = numbuf.format(diagnostic.range.end.character);
    // let message = replace(diagnostic.message.as_bytes(), b'"', br#"\""#);
    let mut buffer = Vec::with_capacity(1000); // reasonable guess, can calculate later on
    buffer.extend_from_slice(b"{\"severity\":1,\"source\":\"rustc\",\"message\":\"");
    buffer.extend_from_slice(diagnostic.message.as_bytes());
    buffer.extend_from_slice(b"\",\"range\":{\"start\":{\"line\":");
    buffer.extend_from_slice(range_start_line.as_bytes());
    buffer.extend_from_slice(b",\"character\":");
    buffer.extend_from_slice(range_start_character.as_bytes());
    buffer.extend_from_slice(b"},\"end\":{\"line\":");
    buffer.extend_from_slice(range_end_line.as_bytes());
    buffer.extend_from_slice(b",\"character\":");
    buffer.extend_from_slice(range_end_character.as_bytes());
    buffer.extend_from_slice(b"}}");
    if let Some(code) = &diagnostic.code {
        buffer.extend_from_slice(b",\"code\":");
        match code {
            NumberOrString::Number(code) => {
                let mut numbuf = itoa::Buffer::new();
                buffer.extend_from_slice(numbuf.format(*code).as_bytes());
            }
            NumberOrString::String(code) => {
                buffer.extend_from_slice(b"\"");
                buffer.extend_from_slice(code.as_bytes());
                buffer.extend_from_slice(b"\"");
            }
        }
    }
    if let Some(related_information) = &diagnostic.related_information {
        fast_serialize_related_information(&mut buffer, &related_information);
    }
    buffer.push(b'}');
    buffer
}

fn fast_serialize_related_information(buffer: &mut Vec<u8>, related_information: &[DiagnosticRelatedInformation]) {
    buffer.extend_from_slice(b",\"relatedInformation\":[");
    for (i, related) in related_information.iter().enumerate() {
        if i != 0 {
            buffer.push(b',');
        }
        buffer.extend_from_slice(b"{\"location\":{\"uri\":\"");
        buffer.extend_from_slice(related.location.uri.to_string().as_bytes());
        buffer.extend_from_slice(b"\",\"range\":{\"start\":{\"line\":");
        let mut buf = itoa::Buffer::new();
        buffer.extend_from_slice(buf.format(related.location.range.start.line).as_bytes());
        buffer.extend_from_slice(b",\"character\":");
        let mut buf = itoa::Buffer::new();
        buffer.extend_from_slice(buf.format(related.location.range.start.character).as_bytes());
        buffer.extend_from_slice(b"},\"end\":{\"line\":");
        let mut buf = itoa::Buffer::new();
        buffer.extend_from_slice(buf.format(related.location.range.end.line).as_bytes());
        buffer.extend_from_slice(b",\"character\":");
        let mut buf = itoa::Buffer::new();
        buffer.extend_from_slice(buf.format(related.location.range.end.character).as_bytes());
        buffer.extend_from_slice(b"}}},\"message\":\"");
        buffer.extend_from_slice(related.message.as_bytes());
        buffer.extend_from_slice(b"\"}");
    }
    buffer.push(b']');
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use lsp_types::{Diagnostic, DiagnosticRelatedInformation, Position, Range};

    #[test]
    fn check_corectness() {
        let diagnostic = Diagnostic {
            range: Range {
                start: lsp_types::Position {
                    line: 1928,
                    character: 28034,
                },
                end: lsp_types::Position {
                    line: 28034,
                    character: 1928,
                },
            },
            severity: Some(lsp_types::DiagnosticSeverity::ERROR),
            code: None,
            code_description: None,
            source: Some("rustc".to_string()),
            message: "message".to_string(),
            related_information: Some(vec![
                DiagnosticRelatedInformation {
                    location: lsp_types::Location {
                        uri: lsp_types::Uri::from_str("file:///path/to/file").unwrap(),
                        range: Range {
                            start: Position {
                                line: 1928,
                                character: 28034,
                            },
                            end: Position {
                                line: 28034,
                                character: 1928,
                            },
                        },
                    },
                    message: "message".to_string(),
                },
                DiagnosticRelatedInformation {
                    location: lsp_types::Location {
                        uri: lsp_types::Uri::from_str("file:///path/to/file").unwrap(),
                        range: Range {
                            start: Position {
                                line: 1928,
                                character: 28034,
                            },
                            end: Position {
                                line: 28034,
                                character: 1928,
                            },
                        },
                    },
                    message: "message".to_string(),
                },
                DiagnosticRelatedInformation {
                    location: lsp_types::Location {
                        uri: lsp_types::Uri::from_str("file:///path/to/file").unwrap(),
                        range: Range {
                            start: Position {
                                line: 1928,
                                character: 28034,
                            },
                            end: Position {
                                line: 28034,
                                character: 1928,
                            },
                        },
                    },
                    message: "message".to_string(),
                },
            ]),
            tags: None,
            data: None,
        };
        let serialized = super::serde_serialize_diagnostic(&diagnostic);
        let fast_serialized = super::fast_serialize_error_diagnostic(&diagnostic);

        let parsed_serde: serde_json::Value = serde_json::from_str(&serialized).unwrap();
        let parsed_fast: serde_json::Value =
            serde_json::from_str(&String::from_utf8(fast_serialized).unwrap()).unwrap();

        assert_eq!(parsed_serde, parsed_fast);
    }
}
